---
title: "Simple_simulations"
author: "Jostein Aasteboel, Aanes and 10920007"
date: "2023-09-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


#Load libraries
library(INLA)
library(tidyverse)
library(spData)
library(sf)
library(spdep)
library(ggplot2)
require(mgcv)
library(MASS)
library(fastmatrix)
library(rwc)
```

```{r load_map}
# read a shapefile, defining the country and subregional borders
map <- st_read(system.file("shapes/columbus.shp",
                           package = "spData"), quiet = TRUE)

# extract the adjacency structure from the graph: map.
# queen = FALSE, since it is closer to being rook adjacency.
nb <- spdep::poly2nb(map, queen = FALSE)

# needed for inla
adjacency_matrix <- nb2mat(nb, style="B")
mydiag = rowSums(adjacency_matrix)
adjacency_matrix <- -adjacency_matrix
diag(adjacency_matrix) <- mydiag
```

```{r preliminaries}
# Define over how many time points to simulate data from 
T = 15
time <- 1:T

# Extract number of regions
n = length(nb)

#Define the zero mean vector for the temporal dimension
zero_vector_T = rep(0, T)

#Define the zero mean vector for the spatial dimension
zero_vector_n= rep(0, n)

#Define the identity matrix for Temporal dimension: TxT
I_T = diag(1, T, T)

#Define identity matrix I_n, dimension nxn
I_n = diag(1, nrow = n, ncol = n)
```

```{r define_precision_matrices_of_effects}
# precision matrix of gamma
Q_gamma = 0.5 * I_T

#Define structure matrix for alpha, structure as RW1
K_alpha = 2 * I_T                   # Get 2 along diag
sdiag(K_alpha, 1) = -1              # -1 along super diag
sdiag(K_alpha, -1) = -1             # -1 along sub diag
K_alpha[1,1] = 1; K_alpha[T,T] = 1  # 1 in upper left and lower right.

# Precision matrix of alpha
Q_alpha = K_alpha

# Precision matrix phi
Q_phi = 0.5 * I_n

# Precision matrix theta
Q_theta = adjacency_matrix

```


```{r sample_effects}
#Sample the effects present in the linear predictor

set.seed(507740)
mu = rnorm(1, mean = 0, sd = 1)    # mu: Somewhat high variance (low precision)

gamma = rnorm.Q(Q_gamma,                  # Precision matrix gamma
                mu = zero_vector_T,       # Prior mean gamma (0,..,0)
                X = Matrix(1, nrow = nrow(Q_gamma), ncol = 1), #Defines a vector which samples are orthogonal too
                zero.constraint = TRUE                         # Make it so samples are orthogonal to (1,...,1)
                ) 

alpha = rnorm.Q(Q_alpha,                  # Precision matrix alpha
                mu = zero_vector_T,       # Prior mean alpha (0,..,0)
                X = Matrix(1, nrow = nrow(Q_alpha), ncol = 1), #Defines a vector which samples are orthogonal too
                zero.constraint = TRUE                         # Make it so samples are orthogonal to (1,...,1)
                ) 

phi = rnorm.Q(Q_phi,                  # Precision matrix phi
                mu = zero_vector_n,       # Prior mean phi (0,..,0)
                X = Matrix(1, nrow = nrow(Q_phi), ncol = 1), #Defines a vector which samples are orthogonal too
                zero.constraint = TRUE                         # Make it so samples are orthogonal to (1,...,1)
                ) 


theta = rnorm.Q(Q_theta,                  # Precision matrix theta
                mu = zero_vector_n,       # Prior mean theta (0,..,0)
                X = Matrix(1, nrow = nrow(Q_theta), ncol = 1), #Defines a vector which samples are orthogonal too
                zero.constraint = TRUE                         # Make it so samples are orthogonal to (1,...,1)
                )
```

```{r define_and_sample_interactions}
#Define the zero matrix for the interaction-space
zero_matrix_interaction = rep(0, n * T)

# structure/precision matrices
delta.prec.I <-   kronecker.prod(I_T, y = I_n)                     #Structure matrix, here used as precision
delta.prec.II <-  kronecker.prod(K_alpha, y = I_n)                 # --||--
delta.prec.III <- kronecker.prod(I_T, y = adjacency_matrix)        # --||--
delta.prec.IV <-  kronecker.prod(K_alpha, y = adjacency_matrix)    # --||--


#Sample interactions of type I - IV:
set.seed(507741)
delta.I = rnorm.Q(delta.prec.I,                  # Precision matrix delta.I
                mu = zero_matrix_interaction,       # Prior mean delta.I (0,..,0)
                X = Matrix(1,                       #Defines a vector which samples are orthogonal too
                           nrow = nrow(delta.prec.I),
                           ncol = 1), 
                zero.constraint = TRUE            # Make it so samples are orthogonal to (1,...,1)
                )

delta.II = rnorm.Q(delta.prec.II,                  # Precision matrix delta.II
                mu = zero_matrix_interaction,       # Prior mean delta.II (0,..,0)
                X = Matrix(1,                       #Defines a vector which samples are orthogonal too
                           nrow = nrow(delta.prec.II),
                           ncol = 1), 
                zero.constraint = TRUE            # Make it so samples are orthogonal to (1,...,1)
                )

delta.III = rnorm.Q(delta.prec.III,                  # Precision matrix delta.III
                mu = zero_matrix_interaction,       # Prior mean delta.III (0,..,0)
                X = Matrix(1,                       #Defines a vector which samples are orthogonal too
                           nrow = nrow(delta.prec.III),
                           ncol = 1), 
                zero.constraint = TRUE            # Make it so samples are orthogonal to (1,...,1)
                )

delta.IV = rnorm.Q(delta.prec.IV,                  # Precision matrix delta.IV
                mu = zero_matrix_interaction,       # Prior mean delta.IV (0,..,0)
                X = Matrix(1,                       #Defines a vector which samples are orthogonal too
                           nrow = nrow(delta.prec.IV),
                           ncol = 1), 
                zero.constraint = TRUE            # Make it so samples are orthogonal to (1,...,1)
                )
```


```{r define_linear_predictor}
#Initiate memory for linear predictor eta.I using type I interaction
eta.I = matrix(0, T, n)

# Get the values for the linear predictor at every time point at every area 
for(t in 1:T){
  for(i in 1:n){
    eta.I[t, i] = mu + alpha[t] + gamma[t] + theta[i] + phi[i] + delta.I[t * i]
  }
}
```

```{r sample_response}
#Binomial or Poisson???

#Binomial logit link
p = exp(eta.I)/(1 + exp(eta.I))

#Poisson link
lambda = exp(eta.I)

#Sample response from Binomial
y_binom = matrix(0, T, n)
set.seed(507745)
for(t in 1:T){
  for(i in 1:n){
    y_binom[t, i] = rbinom(n = 1, 10000, p[t, i])
  }
}


#Sample response from Poisson
y_poisson = matrix(0, T, n)
set.seed(507746)
for (t in 1:T) {
  for (i in 1:n) {
    y_poisson[t, i] = rpois(n = 1, lambda[t, i])
  }
}
```

```{r heat_map}
map$disease <- y_binom[1,]

plot(map['disease'])
```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```


```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```